# --file ../Benchmarks/barycentric_coordinates/SAT/barycentric_coordinates.txt --gverbose -s -i

# Barycentric Coordinates - https://mathworld.wolfram.com/BarycentricCoordinates.html
# Barycentric coordinates are triples of numbers (u, v, w) corresponding to masses placed at the vertices of a
# reference triangle a,b,c. These masses then determine a point P, which is the geometric centroid of the three
# masses and is identified with coordinates (u, v, w).

INPUTS {
	ax fl64 : (-4.0, -1.0);
	ay fl64 : (1.0, 6.0);
	az fl64 : (-6.0, -4.0);
	bx fl64 : (7.0, 10.0);
	by fl64 : (-7.0, -4.0);
	bz fl64 : (8.0, 14.0);
	cx fl64 : (4.441 - 0.5, 4.441 + 0.5);
	cy fl64 : (8.34 - 0.5, 8.34 + 0.5);
	cz fl64 : (-3.35 - 0.5, -3.35 + 0.5);
	px fl64 : (2 - 0.5, 2 + 0.5);
	py fl64 : (3 - 0.5 , 3 + 0.5 );
	pz fl64 : (5 - 0.5  , 5 + 0.5);
}

OUTPUTS {
	w ;
}

EXPRS {
	bax = bx - ax ;
	bay = by - ay ;
	baz = bz - az ;

	cax = cx - ax ;
	cay = cy - ay ;
	caz = cz - az ;

	mx = bay*caz - baz*cay;
	my = baz*cax - bax*caz;
	mz = bax*cay - bay*cax;

	if(( ((mx >= 0) && (my >= 0) && (mx >= my)) || ((mx < 0) && (my >= 0) && (mx+my <= 0)) || 
	    ((mx >= 0) && (my < 0) && (mx + my >= 0)) || ((mx < 0) && (my < 0) && (mx - my <= 0))
		 ) && ( ((mx >= 0) && (mz >= 0) && (mx >= mz)) || ((mx < 0) && (mz >= 0) && (mx+mz <= 0)) || 
	    ((mx >= 0) && (mz < 0) && (mx + mz >= 0)) || ((mx < 0) && (mz < 0) && (mx - mz <= 0))
		 )) then
		nu = (py-by)*(bz-cz) - (by-cy)*(pz-bz);
		nv = (py-cy)*(cz-az) - (cy-ay)*(pz-cz);
		ood = 1.0/mx ;
	else
		if(( ((my >= 0) && (mx >= 0) && (my >= mx)) || ((my < 0) && (mx >= 0) && (my+mx <= 0)) || 
		    ((my >= 0) && (mx < 0) && (my + mx >= 0)) || ((my < 0) && (mx < 0) && (my - mx <= 0))
			 ) && ( ((my >= 0) && (mz >= 0) && (my >= mz)) || ((my < 0) && (mz >= 0) && (my+mz <= 0)) || 
		    ((my >= 0) && (mz < 0) && (my + mz >= 0)) || ((my < 0) && (mz < 0) && (my - mz <= 0))
			 )) then
			nu = (px - bx)*(bz - cz) - (bx - cx)*(pz-bz);
			nv = (px - cx)*(cz - az) - (cx-ax)*(pz-cz);
			ood = 1.0/(-1.0*my);
		else
			nu = (px-bx)*(by-cy) - (bx-cx)*(py-by);
			nv = (px - cx)*(cy-ay) - (cx - ax)*(py - cy);
			ood = 1.0/mz ;			
		endif
		
	endif

	u = nu * ood ;
	v = nv * ood ;
	w = 1.0 - u - v ;
}
